/*
Saviynt Delegated Administration API

Testing DelegatedAdministrationAPIService

*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech);

package test

import (
	"context"
	"fmt"
	"strings"
	"testing"
	"time"

	saviyntapigoclient "github.com/saviynt/saviynt-api-go-client"
	"github.com/saviynt/saviynt-api-go-client/delegatedadministration"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func Test_delegatedadministration_DelegatedAdministrationAPIService(t *testing.T) {
	apiClient, creds, wantTest, err := client()
	require.Nil(t, err)

	ctx := context.Background()

	layoutDT8MYD := "01022006"
	dateLayoutCreateDelegateRequest := layoutDT8MYD
	layoutM2D2Y4Slash := "01/02/2006"
	dateLayoutFetchDelegatesResponse := layoutM2D2Y4Slash

	delegatesAvailable := DelegateUsers{}
	delegatesExisting := Delegates{}
	delegateCreateRequest := delegatedadministration.CreateDelegateRequest{}
	delegateCreateResponse := delegatedadministration.CreateDelegateResponse{}

	t.Run("Test_DelegatedAdministrationAPIService_GetDelegateUserList", func(t *testing.T) {
		if !wantTest {
			t.Skip("skip test") // remove to run test
		}

		req := delegatedadministration.GetDelegateUserListRequest{
			Parentusername: creds.Username,
			Max:            saviyntapigoclient.Pointer(int32(10)),
			Offset:         saviyntapigoclient.Pointer(int32(0))}

		resp, httpRes, err := apiClient.DelegatedAdministration.
			GetDelegateUserList(ctx).
			GetDelegateUserListRequest(req).
			Execute()

		require.Nil(t, err)
		require.NotNil(t, httpRes)
		assert.Equal(t, 200, httpRes.StatusCode)
		require.NotNil(t, resp)

		delegatesAvailable = resp.Result
	})

	t.Run("Test_DelegatedAdministrationAPIService_FetchDelegatesList", func(t *testing.T) {
		if !wantTest {
			t.Skip("skip test") // remove to run test
		}

		req := delegatedadministration.FetchDelegatesListRequest{
			UserName: creds.Username}

		resp, httpRes, err := apiClient.DelegatedAdministration.
			FetchDelegatesList(ctx).
			FetchDelegatesListRequest(req).
			Execute()

		require.Nil(t, err)
		require.NotNil(t, httpRes)
		assert.Equal(t, 200, httpRes.StatusCode)
		require.NotNil(t, resp)
		assert.Equal(t, "0", resp.ErrorCode)

		delegatesExisting = resp.DelegateList
	})

	t.Run("Test_DelegatedAdministrationAPIService_CreateDelegate", func(t *testing.T) {
		if !wantTest {
			t.Skip("skip test") // remove to run test
		}

		tr, err := delegatesExisting.MaxTimeRange(dateLayoutFetchDelegatesResponse)
		require.Nil(t, err)
		tMax := tr.MaxOrDefault(time.Now())
		t30 := tMax.Add(time.Hour * 24 * 30)
		t60 := tMax.Add(time.Hour * 24 * 60)

		candidates := delegatesAvailable.Usernames([]string{creds.Username})
		assert.Greater(t, len(candidates), 0)

		req := delegatedadministration.CreateDelegateRequest{
			UserName:          creds.Username,
			Name:              fmt.Sprintf("Delegate for %s to %s", t30.Format(time.DateOnly), t60.Format(time.DateOnly)), // Delegate Name
			Delegateusername:  candidates[0],                                                                              // Must match `username` in `GetDelegateUserList`
			Delegatestartdate: t30.Format(dateLayoutCreateDelegateRequest),
			Delegateenddate:   t60.Format(dateLayoutCreateDelegateRequest)}

		resp, httpRes, err := apiClient.DelegatedAdministration.
			CreateDelegate(ctx).
			CreateDelegateRequest(req).
			Execute()

		require.Nil(t, err)
		require.NotNil(t, httpRes)
		assert.Equal(t, 200, httpRes.StatusCode)
		require.NotNil(t, resp)
		assert.Equal(t, "0", resp.ErrorCode)
		if resp != nil && resp.ErrorCode != "0" && strings.TrimSpace(resp.Msg) != "" {
			t.Errorf("error message: (%s)", resp.Msg)
		}

		delegateCreateRequest = req
		delegateCreateResponse = *resp
	})

	t.Run("Test_DelegatedAdministrationAPIService_EditDelegate", func(t *testing.T) {
		if !wantTest || delegateCreateResponse.Delegatekey == nil || *delegateCreateResponse.Delegatekey == "" {
			t.Skip("skip test") // remove to run test
		}

		req := delegatedadministration.EditDelegateRequest{
			Key:               *delegateCreateResponse.Delegatekey,
			UserName:          delegateCreateRequest.UserName,
			Name:              delegateCreateRequest.Name,
			Delegateusername:  delegateCreateRequest.Delegateusername,
			Delegatestartdate: delegateCreateRequest.Delegatestartdate,
			Delegateenddate:   delegateCreateRequest.Delegateenddate,
			Description:       saviyntapigoclient.Pointer("Updated at " + time.Now().UTC().Format(time.RFC3339)),
		}

		resp, httpRes, err := apiClient.DelegatedAdministration.
			EditDelegate(ctx).
			EditDelegateRequest(req).
			Execute()

		require.Nil(t, err)
		require.NotNil(t, httpRes)
		assert.Equal(t, 200, httpRes.StatusCode)
		require.NotNil(t, resp)
		assert.Equal(t, "0", resp.ErrorCode)
	})

	t.Run("Test_DelegatedAdministrationAPIService_DeleteDelegate", func(t *testing.T) {
		if !wantTest || delegateCreateResponse.Delegatekey == nil || *delegateCreateResponse.Delegatekey == "" {
			t.Skip("skip test") // remove to run test
		}

		resp, httpRes, err := apiClient.DelegatedAdministration.
			DeleteDelegate(ctx).
			UserName(creds.Username).
			Key(*delegateCreateResponse.Delegatekey).
			Execute()

		require.Nil(t, err)
		require.NotNil(t, httpRes)
		assert.Equal(t, 200, httpRes.StatusCode)
		require.NotNil(t, resp)
		assert.Equal(t, "0", resp.ErrorCode)
	})
}

type DelegateUsers []delegatedadministration.DelegateUser

func (dels DelegateUsers) Usernames(exclUsernames []string) []string {
	var users []string
	exclMap := map[string]int{}
	for _, exclUsername := range exclUsernames {
		exclMap[exclUsername]++
	}
	for _, del := range dels {
		if _, ok := exclMap[del.Username]; ok {
			continue
		}
		users = append(users, del.Username)
	}
	return users
}

type Delegates []delegatedadministration.Delegate

func (dels Delegates) Keys() []string {
	var keys []string
	for _, del := range dels {
		keys = append(keys, del.Delegatekey)
	}
	return keys
}

type TimeRange struct {
	InputLayout  string
	OutputLayout string
	Min          *time.Time
	Max          *time.Time
}

func (tr *TimeRange) AddTime(t time.Time) {
	if tr.Min == nil || t.Before(*tr.Min) {
		tr.Min = &t
	}
	if tr.Max == nil || t.After(*tr.Max) {
		tr.Max = &t
	}
}

func (tr *TimeRange) MaxOrDefault(def time.Time) time.Time {
	if tr.Max == nil {
		return def
	} else if tr.Max.After(def) {
		return *tr.Max
	} else {
		return def
	}
}

func (tr *TimeRange) MinOrDefault(def time.Time) time.Time {
	if tr.Min == nil {
		return def
	} else if tr.Min.Before(def) {
		return *tr.Min
	} else {
		return def
	}
}

func (tr *TimeRange) AddParseTime(layout string, value string) error {
	if layout == "" {
		layout = tr.InputLayout
	}
	if t, err := time.Parse(layout, value); err != nil {
		return err
	} else {
		tr.AddTime(t)
		return nil
	}
}

func (dels Delegates) MaxTimeRange(dateLayout string) (TimeRange, error) {
	tr := TimeRange{
		InputLayout: dateLayout,
	}

	for _, del := range dels {
		sta := strings.TrimSpace(del.Startdate)
		if sta != "" {
			if err := tr.AddParseTime("", sta); err != nil {
				return tr, err
			}
		}
		end := strings.TrimSpace(del.Enddate)
		if end != "" {
			if err := tr.AddParseTime("", end); err != nil {
				return tr, err
			}
		}
	}

	return tr, nil
}
