/*
Organization Management API

API for creating, updating, retrieving, and deleting organization data in EIC

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// OrganizationsAPIService OrganizationsAPI service
type OrganizationsAPIService service

type ApiCreateOrganizationRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	createOrganizationRequest *CreateOrganizationRequest
}

func (r ApiCreateOrganizationRequest) CreateOrganizationRequest(createOrganizationRequest CreateOrganizationRequest) ApiCreateOrganizationRequest {
	r.createOrganizationRequest = &createOrganizationRequest
	return r
}

func (r ApiCreateOrganizationRequest) Execute() (*CreateOrganization200Response, *http.Response, error) {
	return r.ApiService.CreateOrganizationExecute(r)
}

/*
CreateOrganization Create Organization

This API creates an organization in SSM.
The `Authorization header must contain "Bearer {token}.
**Mandatory Parameters:**
- organizationname: Specify a unique name for the organization.
- username: Specify the user who is creating the organization.

**Optional Parameters:**
- parentorganization
- primarycontact
- customproperty1 (or customproperty1 to customproperty20)
- organizationtype: Allowed values are DATA, SECURITY, GROUPING, or REQUEST RULES.
- endpoints: Each with an endpointname and optional cp1...cp5.
- roles: Each with a rolename.
- rules: Each with a name and type (BUISNESS, TECH, USERUPDATE, NEWUSER, REMOVEUSER, UPDATE_ENTITLEMENT, NEW_ENTITLEMENT, REMOVE_ENTITLEMENT, or REQUEST).
- entitlements: Each with entitlementvalue, entitlementtype, and endpoint.
- users: A list of user objects (with username).
- owners: Each with owner, rank, and policy (SUPERADMIN, ADMIN, BULKADMIN, USERADMIN, CAMPAIGNADMIN, or READONLY).
- attributes: Each with attributegroupname, attributes, value, and attributevalues.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrganizationRequest
*/
func (a *OrganizationsAPIService) CreateOrganization(ctx context.Context) ApiCreateOrganizationRequest {
	return ApiCreateOrganizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateOrganization200Response
func (a *OrganizationsAPIService) CreateOrganizationExecute(r ApiCreateOrganizationRequest) (*CreateOrganization200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateOrganization200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.CreateOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/createOrganization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrganizationRequest == nil {
		return localVarReturnValue, nil, reportError("createOrganizationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrganizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOrganizationRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	deleteOrganizationRequest *DeleteOrganizationRequest
}

func (r ApiDeleteOrganizationRequest) DeleteOrganizationRequest(deleteOrganizationRequest DeleteOrganizationRequest) ApiDeleteOrganizationRequest {
	r.deleteOrganizationRequest = &deleteOrganizationRequest
	return r
}

func (r ApiDeleteOrganizationRequest) Execute() (*DeleteOrganization200Response, *http.Response, error) {
	return r.ApiService.DeleteOrganizationExecute(r)
}

/*
DeleteOrganization Delete Organization

Use this API to delete an organization in EIC.

The **Authorization** header must have `Bearer` followed by the token.

**Mandatory Parameters:**
- `organizationname`: The unique name of the organization to delete.
- `username`: The user performing the delete action.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteOrganizationRequest
*/
func (a *OrganizationsAPIService) DeleteOrganization(ctx context.Context) ApiDeleteOrganizationRequest {
	return ApiDeleteOrganizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteOrganization200Response
func (a *OrganizationsAPIService) DeleteOrganizationExecute(r ApiDeleteOrganizationRequest) (*DeleteOrganization200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteOrganization200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.DeleteOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/deleteOrganization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteOrganizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrganizationRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	getOrganizationRequest *GetOrganizationRequest
}

func (r ApiGetOrganizationRequest) GetOrganizationRequest(getOrganizationRequest GetOrganizationRequest) ApiGetOrganizationRequest {
	r.getOrganizationRequest = &getOrganizationRequest
	return r
}

func (r ApiGetOrganizationRequest) Execute() (*GetOrganization200Response, *http.Response, error) {
	return r.ApiService.GetOrganizationExecute(r)
}

/*
GetOrganization Get Organization

Use this API to fetch a list of all organizations in EIC.
The `Authorization` must have `Bearer` followed by a valid token.

**Optional Parameters:**
- `organizationname`
- `max`
- `offset`
- `filtercriteria` – one of: organizationname, organizationtype (possible values: Data Security, Request Rules, Grouping, 1, 2, 3), status ("ACTIVE"/"INACTIVE"), updateuser (username), createuser (username), parentorganization, customproperty1–20, description, primarycontact (username), vendormanager (username), location, risk, score.

_OR_

- `orgQuery` (e.g., `c.organizationname like '%example_orgname%'`)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrganizationRequest
*/
func (a *OrganizationsAPIService) GetOrganization(ctx context.Context) ApiGetOrganizationRequest {
	return ApiGetOrganizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetOrganization200Response
func (a *OrganizationsAPIService) GetOrganizationExecute(r ApiGetOrganizationRequest) (*GetOrganization200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetOrganization200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.GetOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/getOrganization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getOrganizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrganizationUserDetailsRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	getOrganizationUserDetailsRequest *GetOrganizationUserDetailsRequest
}

func (r ApiGetOrganizationUserDetailsRequest) GetOrganizationUserDetailsRequest(getOrganizationUserDetailsRequest GetOrganizationUserDetailsRequest) ApiGetOrganizationUserDetailsRequest {
	r.getOrganizationUserDetailsRequest = &getOrganizationUserDetailsRequest
	return r
}

func (r ApiGetOrganizationUserDetailsRequest) Execute() (*GetOrganizationUserDetails200Response, *http.Response, error) {
	return r.ApiService.GetOrganizationUserDetailsExecute(r)
}

/*
GetOrganizationUserDetails Get User Organization

Use this API to fetch all organizations (both primary and secondary) associated with a user.

**Note:**
- You must enable the **Enable Multiple Organizations for a User** option from the Global Configurations page in the EIC user interface to fetch the organizations associated with a user.
- Starting with Release v24.7, this API now also retrieves the start date and end date for new or existing users that belong to the secondary organization.

The `Authorization` header must have `Bearer` followed by a valid token.

**Mandatory Parameter:**
- **username**: The name of the user whose associated organization details you want to fetch.

**Optional Parameters:**
- **max**: The maximum number of records to return.
- **offset**: The offset value for pagination.
- **orgQuery**: A query string to filter organizations (e.g. `c.organizationname like '%example%'`).
- **verbose**: Set to `true` to retrieve additional information (e.g. organizationname, displayname, description, or status).
- **fetchonlycount**: Set to `true` or `false` to indicate if only the total count is required.
- **orgmemebership**: Specify if you want details for a particular type of organization (for example, `primary` or `secondary`).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrganizationUserDetailsRequest
*/
func (a *OrganizationsAPIService) GetOrganizationUserDetails(ctx context.Context) ApiGetOrganizationUserDetailsRequest {
	return ApiGetOrganizationUserDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetOrganizationUserDetails200Response
func (a *OrganizationsAPIService) GetOrganizationUserDetailsExecute(r ApiGetOrganizationUserDetailsRequest) (*GetOrganizationUserDetails200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetOrganizationUserDetails200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.GetOrganizationUserDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/getOrganizationUserDetails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getOrganizationUserDetailsRequest == nil {
		return localVarReturnValue, nil, reportError("getOrganizationUserDetailsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getOrganizationUserDetailsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrganizationRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	updateOrganizationRequest *UpdateOrganizationRequest
}

func (r ApiUpdateOrganizationRequest) UpdateOrganizationRequest(updateOrganizationRequest UpdateOrganizationRequest) ApiUpdateOrganizationRequest {
	r.updateOrganizationRequest = &updateOrganizationRequest
	return r
}

func (r ApiUpdateOrganizationRequest) Execute() (*CreateOrganization200Response, *http.Response, error) {
	return r.ApiService.UpdateOrganizationExecute(r)
}

/*
UpdateOrganization Update Organization

This API updates an organization in EIC.
The `Authorization` must have `Bearer` followed by `Token`.
**Mandatory Parameters:**
- `organizationname`: Specify a unique name of the organization.
- `username`: Specify the user who is updating the organization.

**Optional Parameters:**
- `updatedorgname` - parameter to update the organization name.
- `parentorganization`
- `primarycontact`
- `endpoints` - List of endpoints with:
    - `endpointname`
    - `updatetype`: ADD or REMOVE
- `roles` - List of roles with:
    - `rolename`
    - `updatetype`: ADD or REMOVE
- `rules` - List of rules with:
    - `name`
    - `type`: BUISNESS, TECH, USERUPDATE, NEWUSER, REMOVEUSER, UPDATE_ENTITLEMENT, NEW_ENTITLEMENT, REMOVE_ENTITLEMENT, or REQUEST.
    - `updatetype`: ADD or REMOVE
- `entitlements` - List of entitlements with:
    - `entitlementvalue`
    - `entitlementtype`
    - `endpoint`
    - `updatetype`: add or remove
- `users` - List of users with:
    - `username`
    - `updatetype`: add or remove
- `owners` - List with:
    - `owner`
    - `rank`
    - `updatetype`: add, update, or remove
    - `policy`: SUPERADMIN, ADMIN, BULKADMIN, USERADMIN, CAMPAIGNADMIN, or READONLY.
- `attributes` - List with:
    - `attributegroupname`
    - `attributes`
    - `value`
    - `attributevalues`
    - `updatetype`: addgroup, deletegroup, or updategroup.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateOrganizationRequest
*/
func (a *OrganizationsAPIService) UpdateOrganization(ctx context.Context) ApiUpdateOrganizationRequest {
	return ApiUpdateOrganizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateOrganization200Response
func (a *OrganizationsAPIService) UpdateOrganizationExecute(r ApiUpdateOrganizationRequest) (*CreateOrganization200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateOrganization200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.UpdateOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/updateOrganization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateOrganizationRequest == nil {
		return localVarReturnValue, nil, reportError("updateOrganizationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateOrganizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrganizationUsersRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	updateOrganizationUsersRequest *UpdateOrganizationUsersRequest
}

func (r ApiUpdateOrganizationUsersRequest) UpdateOrganizationUsersRequest(updateOrganizationUsersRequest UpdateOrganizationUsersRequest) ApiUpdateOrganizationUsersRequest {
	r.updateOrganizationUsersRequest = &updateOrganizationUsersRequest
	return r
}

func (r ApiUpdateOrganizationUsersRequest) Execute() (*UpdateOrganizationUsers200Response, *http.Response, error) {
	return r.ApiService.UpdateOrganizationUsersExecute(r)
}

/*
UpdateOrganizationUsers Update Organization Users

Use this API to add or remove multiple users from the secondary organization in EIC.

**Note**: You must enable the **Enable Multiple Organizations for a User** option in the Global Configurations page of the EIC UI.

The **Authorization** header must contain `Bearer` followed by the token.

**Mandatory Parameters:**
- `organizationname`: The name of the secondary organization whose associated users are to be fetched.
- `users`: A list of user objects to add or remove. Each user object must include:
    - `username`: The username of the user to add or remove.
    - `updatetype`: The action to perform. Use `add` for adding a user and `remove` for removing a user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateOrganizationUsersRequest
*/
func (a *OrganizationsAPIService) UpdateOrganizationUsers(ctx context.Context) ApiUpdateOrganizationUsersRequest {
	return ApiUpdateOrganizationUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateOrganizationUsers200Response
func (a *OrganizationsAPIService) UpdateOrganizationUsersExecute(r ApiUpdateOrganizationUsersRequest) (*UpdateOrganizationUsers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateOrganizationUsers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.UpdateOrganizationUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/updateOrganizationUsers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateOrganizationUsersRequest == nil {
		return localVarReturnValue, nil, reportError("updateOrganizationUsersRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateOrganizationUsersRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
