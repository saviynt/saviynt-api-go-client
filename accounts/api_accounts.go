/*
Account Management API

API for managing accounts in Saviynt/SSM. - **Create Account**: Creates a new account record. - **Update Account**: Updates an existing account based on its name. - **Export Account**: Retrieves all existing accounts for a given endpoint and security system. - **Get Account Details**: Returns a list of accounts based on search criteria. - **Assign Account to User**: Provisions an account to a user. - **Assign Entitlement to Account**: Provisions one or more entitlements to an account. - **Remove Entitlement from Account**: Deprovisions one or more entitlements from an account. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AccountsAPIService AccountsAPI service
type AccountsAPIService service

type ApiAssignAccountToEntitlementRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	securitysystem *string
	endpoint *string
	accountname *string
	entitlementtype *string
	entitlementvalue *string
	startdate *string
}

// Name of the Security System (not the display name).
func (r ApiAssignAccountToEntitlementRequest) Securitysystem(securitysystem string) ApiAssignAccountToEntitlementRequest {
	r.securitysystem = &securitysystem
	return r
}

// Name of the Endpoint corresponding to the Security System (not the display name).
func (r ApiAssignAccountToEntitlementRequest) Endpoint(endpoint string) ApiAssignAccountToEntitlementRequest {
	r.endpoint = &endpoint
	return r
}

// Account name to which entitlements should be provisioned.
func (r ApiAssignAccountToEntitlementRequest) Accountname(accountname string) ApiAssignAccountToEntitlementRequest {
	r.accountname = &accountname
	return r
}

// Entitlement type (e.g., AD Groups, EBS Responsibilities, SAP Roles).
func (r ApiAssignAccountToEntitlementRequest) Entitlementtype(entitlementtype string) ApiAssignAccountToEntitlementRequest {
	r.entitlementtype = &entitlementtype
	return r
}

// Name(s) of the entitlement(s) to be provisioned.
func (r ApiAssignAccountToEntitlementRequest) Entitlementvalue(entitlementvalue string) ApiAssignAccountToEntitlementRequest {
	r.entitlementvalue = &entitlementvalue
	return r
}

// Start date for the access period in MM-DD-YYYY format.
func (r ApiAssignAccountToEntitlementRequest) Startdate(startdate string) ApiAssignAccountToEntitlementRequest {
	r.startdate = &startdate
	return r
}

func (r ApiAssignAccountToEntitlementRequest) Execute() (*CreateAccount200Response, *http.Response, error) {
	return r.ApiService.AssignAccountToEntitlementExecute(r)
}

/*
AssignAccountToEntitlement Assign Entitlement to Account

This method provisions one or more "Entitlements" to an "Account". The "Entitlements" and the "Account" correspond to a particular IT Application (e.g. Microsoft Active Directory) which is modeled in SSM as an "Endpoint" of a "Security System".

**Mandatory Parameters:**
- **securitysystem**: Name of the Security System for the relevant IT Application.
- **endpoint**: Name of the Endpoint corresponding to the Security System.
- **accountname**: Account name to which the entitlements should be provisioned.
- **entitlementtype**: The type of the entitlement (e.g., AD Groups, EBS Responsibilities, SAP Roles, etc.).
- **entitlementvalue**: The actual entitlement value(s) to be provisioned.
- **startdate**: The start date for the access period in MM-DD-YYYY format (e.g., 12-23-2022).

The `Authorization` header must have `Bearer` followed by the token.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAssignAccountToEntitlementRequest
*/
func (a *AccountsAPIService) AssignAccountToEntitlement(ctx context.Context) ApiAssignAccountToEntitlementRequest {
	return ApiAssignAccountToEntitlementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccount200Response
func (a *AccountsAPIService) AssignAccountToEntitlementExecute(r ApiAssignAccountToEntitlementRequest) (*CreateAccount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.AssignAccountToEntitlement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/assignAccountToEntitlement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.securitysystem == nil {
		return localVarReturnValue, nil, reportError("securitysystem is required and must be specified")
	}
	if r.endpoint == nil {
		return localVarReturnValue, nil, reportError("endpoint is required and must be specified")
	}
	if r.accountname == nil {
		return localVarReturnValue, nil, reportError("accountname is required and must be specified")
	}
	if r.entitlementtype == nil {
		return localVarReturnValue, nil, reportError("entitlementtype is required and must be specified")
	}
	if r.entitlementvalue == nil {
		return localVarReturnValue, nil, reportError("entitlementvalue is required and must be specified")
	}
	if r.startdate == nil {
		return localVarReturnValue, nil, reportError("startdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "securitysystem", r.securitysystem, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "endpoint", r.endpoint, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "accountname", r.accountname, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "entitlementtype", r.entitlementtype, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "entitlementvalue", r.entitlementvalue, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "startdate", r.startdate, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v AssignAccountToEntitlementDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignAccountToUserRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	securitysystem *string
	endpoint *string
	accountname *string
	username *string
}

// Name of the Security System (not the display name).
func (r ApiAssignAccountToUserRequest) Securitysystem(securitysystem string) ApiAssignAccountToUserRequest {
	r.securitysystem = &securitysystem
	return r
}

// Name of the Endpoint corresponding to the Security System (not the display name).
func (r ApiAssignAccountToUserRequest) Endpoint(endpoint string) ApiAssignAccountToUserRequest {
	r.endpoint = &endpoint
	return r
}

// Account name for the provisioned account.
func (r ApiAssignAccountToUserRequest) Accountname(accountname string) ApiAssignAccountToUserRequest {
	r.accountname = &accountname
	return r
}

// Username of the user to whom the account is to be provisioned.
func (r ApiAssignAccountToUserRequest) Username(username string) ApiAssignAccountToUserRequest {
	r.username = &username
	return r
}

func (r ApiAssignAccountToUserRequest) Execute() (*CreateAccount200Response, *http.Response, error) {
	return r.ApiService.AssignAccountToUserExecute(r)
}

/*
AssignAccountToUser Assign Account to User

This method provisions an "Account" to a "User" in SSM. The "Account" corresponds to a particular IT Application (e.g. Microsoft Active Directory) which is modeled in SSM as an "Endpoint" of a "Security System".

**Mandatory Parameters:**
- `securitysystem`: Name of the Security System for the relevant IT Application modeled in SSM.
- `endpoint`: Name of the Endpoint corresponding to the Security System.
- `accountname`: Account name for the provisioned account.
- `username`: Username of the user to whom the account has to be provisioned.

The `Authorization` header must have `Bearer` followed by the token.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAssignAccountToUserRequest
*/
func (a *AccountsAPIService) AssignAccountToUser(ctx context.Context) ApiAssignAccountToUserRequest {
	return ApiAssignAccountToUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccount200Response
func (a *AccountsAPIService) AssignAccountToUserExecute(r ApiAssignAccountToUserRequest) (*CreateAccount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.AssignAccountToUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/assignAccountToUser"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.securitysystem == nil {
		return localVarReturnValue, nil, reportError("securitysystem is required and must be specified")
	}
	if r.endpoint == nil {
		return localVarReturnValue, nil, reportError("endpoint is required and must be specified")
	}
	if r.accountname == nil {
		return localVarReturnValue, nil, reportError("accountname is required and must be specified")
	}
	if r.username == nil {
		return localVarReturnValue, nil, reportError("username is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "securitysystem", r.securitysystem, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "endpoint", r.endpoint, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "accountname", r.accountname, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "username", r.username, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v AssignAccountToUserDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	createAccountRequest *CreateAccountRequest
}

// Request payload for creating an account.
func (r ApiCreateAccountRequest) CreateAccountRequest(createAccountRequest CreateAccountRequest) ApiCreateAccountRequest {
	r.createAccountRequest = &createAccountRequest
	return r
}

func (r ApiCreateAccountRequest) Execute() (*CreateAccount200Response, *http.Response, error) {
	return r.ApiService.CreateAccountExecute(r)
}

/*
CreateAccount Create Account

This method creates a new "account" for an "endpoint" in SSM. All the input parameters it requires are attributes with which the new account record would get created.

The **Authorization** header variable must be set to `Bearer` followed by `Token`.

**Mandatory parameters:**
- `securitysystem`: The security system (not the display name).
- `endpoint`: The endpoint (not the display name).
- `name`: The account name to be created.

**Optional parameters:**
- `accountid`
- `username`: The user for whom the account is created.
- `requestor`: The user who is creating the account.
- `accountowner`: An array of objects representing the owner of the account. Each object must include:
    - `type`: (mandatory; e.g., "user" or "usergroup")
    - `value`: (mandatory; username or usergroup name)
    - `rank`: (optional; values from "1" to "5", default is "1")
- `description`
- `displayname`
- `comments`
- `customproperty1` to `customproperty56`
- `passwordchangestatus`
- `privileged`
- `usergroup`
- `status`: Allowed values such as "Manually Suspended", "Manually Provisioned", "SUSPENDED FROM IMPORT SERVICE", or numeric values ("1", "2", "3", "4"); default is "1"
- `accounttype`: Allowed values such as "Service Account", "Shared Account", "FIREFIGHTERID"; default is null
- `incorrectlogons`
- `orphan`: "true" or "false"
- `validfrom`: Date in MM-dd-yyyy format
- `validthrough`: Date in MM-dd-yyyy format
- `lastlogondate`: Date in MM-dd-yyyy format
- `passwordlockdate`: Date in MM-dd-yyyy format
- `lastpasswordchange`: Date in MM-dd-yyyy format

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountRequest
*/
func (a *AccountsAPIService) CreateAccount(ctx context.Context) ApiCreateAccountRequest {
	return ApiCreateAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccount200Response
func (a *AccountsAPIService) CreateAccountExecute(r ApiCreateAccountRequest) (*CreateAccount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.CreateAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/createAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountRequest == nil {
		return localVarReturnValue, nil, reportError("createAccountRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v CreateAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportAccountRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	securitysystem *string
	endpoint *string
	username *string
	max *string
	offset *string
	accountQuery *string
	advsearchcriteria *ExportAccountRequestAdvsearchcriteria
}

// The security system (not the display name).
func (r ApiExportAccountRequest) Securitysystem(securitysystem string) ApiExportAccountRequest {
	r.securitysystem = &securitysystem
	return r
}

// The endpoint (not the display name).
func (r ApiExportAccountRequest) Endpoint(endpoint string) ApiExportAccountRequest {
	r.endpoint = &endpoint
	return r
}

// Optional username filter.
func (r ApiExportAccountRequest) Username(username string) ApiExportAccountRequest {
	r.username = &username
	return r
}

// Maximum number of records to return.
func (r ApiExportAccountRequest) Max(max string) ApiExportAccountRequest {
	r.max = &max
	return r
}

// Pagination offset.
func (r ApiExportAccountRequest) Offset(offset string) ApiExportAccountRequest {
	r.offset = &offset
	return r
}

// A query string to filter accounts.
func (r ApiExportAccountRequest) AccountQuery(accountQuery string) ApiExportAccountRequest {
	r.accountQuery = &accountQuery
	return r
}

func (r ApiExportAccountRequest) Advsearchcriteria(advsearchcriteria ExportAccountRequestAdvsearchcriteria) ApiExportAccountRequest {
	r.advsearchcriteria = &advsearchcriteria
	return r
}

func (r ApiExportAccountRequest) Execute() (*ExportAccount200Response, *http.Response, error) {
	return r.ApiService.ExportAccountExecute(r)
}

/*
ExportAccount Export Account

This API call can be used to fetch all the existing accounts in a particular endpoint and security system along with the account attributes.

The **Authorization** header must have `Bearer <Token>`.

**Mandatory parameters:**
- `securitysystem`: The security system (not the display name).
- `endpoint`: The endpoint (not the display name).

**Optional parameters:**
- `username`
- `max`
- `offset`
- `accountQuery`
- `advsearchcriteria`: An object with advanced search criteria for accounts.  
  Its properties include:
    - `accountKey`
    - `description`
    - `comments`
    - `accounttype`
    - `status`
    - `customproperties`: (for customproperty1 to customproperty56)
    - `accountID`
    - `displayName`
    - `name`
    - `creator`
    - `updateuser`
    - `validfromDate`
    - `validthrough`
    - `createdon`
    - `lastlogondate`
    - `lastpasswordchange`
    - `updatedate`
    - `orphan`
    - `accountowner`: an array of objects with:
        - `type` (mandatory, e.g. "user" or "usergroup")
        - `value` (mandatory, e.g. username or usergroup name)
        - `rank` (optional, e.g. "1" to "5")

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExportAccountRequest
*/
func (a *AccountsAPIService) ExportAccount(ctx context.Context) ApiExportAccountRequest {
	return ApiExportAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExportAccount200Response
func (a *AccountsAPIService) ExportAccountExecute(r ApiExportAccountRequest) (*ExportAccount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportAccount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.ExportAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/exportAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.securitysystem == nil {
		return localVarReturnValue, nil, reportError("securitysystem is required and must be specified")
	}
	if r.endpoint == nil {
		return localVarReturnValue, nil, reportError("endpoint is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "securitysystem", r.securitysystem, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "endpoint", r.endpoint, "", "")
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "username", r.username, "", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "max", r.max, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "offset", r.offset, "", "")
	}
	if r.accountQuery != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "accountQuery", r.accountQuery, "", "")
	}
	if r.advsearchcriteria != nil {
		paramJson, err := parameterToJson(*r.advsearchcriteria)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("advsearchcriteria", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountsRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	getAccountsRequest *GetAccountsRequest
}

func (r ApiGetAccountsRequest) GetAccountsRequest(getAccountsRequest GetAccountsRequest) ApiGetAccountsRequest {
	r.getAccountsRequest = &getAccountsRequest
	return r
}

func (r ApiGetAccountsRequest) Execute() (*GetAccounts200Response, *http.Response, error) {
	return r.ApiService.GetAccountsExecute(r)
}

/*
GetAccounts Get Account Details

This method returns a list of "Accounts" in SSM.
The Authorization header must have "Bearer {token}".

**Optional Parameters:**
- **username**: Filter accounts by username.
- **endpoint**: Filter accounts by endpoint.
- **max**: Maximum number of records to return.
- **offset**: Pagination offset.
- **accountQuery**: A query string to filter accounts.
- **advsearchcriteria**: Advanced search criteria for accounts.  
  The following fields can be used:
  - accountKey
  - description
  - comments
  - accounttype
  - status
  - customproperties (for customproperty1 to customproperty56)
  - accountID
  - displayName
  - name
  - creator (username)
  - updateuser (username)
  - validfromDate
  - validthrough
  - createdon
  - lastlogondate
  - lastpasswordchange
  - updatedate
  - orphan (true/false)
  - accountowner: an array of objects, each with:
      - type (mandatory; e.g., user or usergroup)
      - value (mandatory; username or usergroup name)
      - rank (optional; e.g., "1" to "5")

**Note:** For OR conditions in queries, enclose them in parenthesis.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountsRequest
*/
func (a *AccountsAPIService) GetAccounts(ctx context.Context) ApiGetAccountsRequest {
	return ApiGetAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAccounts200Response
func (a *AccountsAPIService) GetAccountsExecute(r ApiGetAccountsRequest) (*GetAccounts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccounts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.GetAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/getAccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getAccountsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveAccountToEntitlementRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	securitysystem *string
	endpoint *string
	accountname *string
	entitlementtype *string
	entitlementvalue *string
}

// Name of the Security System (not the display name).
func (r ApiRemoveAccountToEntitlementRequest) Securitysystem(securitysystem string) ApiRemoveAccountToEntitlementRequest {
	r.securitysystem = &securitysystem
	return r
}

// Name of the Endpoint corresponding to the Security System (not the display name).
func (r ApiRemoveAccountToEntitlementRequest) Endpoint(endpoint string) ApiRemoveAccountToEntitlementRequest {
	r.endpoint = &endpoint
	return r
}

// Account name from which entitlements should be deprovisioned.
func (r ApiRemoveAccountToEntitlementRequest) Accountname(accountname string) ApiRemoveAccountToEntitlementRequest {
	r.accountname = &accountname
	return r
}

// Entitlement type (e.g., AD Groups, EBS Responsibilities, SAP Roles).
func (r ApiRemoveAccountToEntitlementRequest) Entitlementtype(entitlementtype string) ApiRemoveAccountToEntitlementRequest {
	r.entitlementtype = &entitlementtype
	return r
}

// Names of the entitlement(s) to be deprovisioned.
func (r ApiRemoveAccountToEntitlementRequest) Entitlementvalue(entitlementvalue string) ApiRemoveAccountToEntitlementRequest {
	r.entitlementvalue = &entitlementvalue
	return r
}

func (r ApiRemoveAccountToEntitlementRequest) Execute() (*CreateAccount200Response, *http.Response, error) {
	return r.ApiService.RemoveAccountToEntitlementExecute(r)
}

/*
RemoveAccountToEntitlement Remove Entitlement from Account

This method deprovisions one or more "Entitlements" from an "Account". The "Entitlements" and the "Account" correspond to a particular IT Application (e.g. Microsoft Active Directory) which is modeled in SSM as an "Endpoint" of a "Security System".

**Mandatory Parameters:**
- **securitysystem**: Name of the Security System for the relevant IT Application.
- **endpoint**: Name of the Endpoint corresponding to the Security System.
- **accountname**: Account name from which the entitlements should be deprovisioned.
- **entitlementtype**: Entitlement type for the entitlements to be deprovisioned (e.g., AD Groups, EBS Responsibilities, SAP Roles).
- **entitlementvalue**: The actual entitlement value(s) to be deprovisioned.

The `Authorization` header must have `Bearer` followed by a valid token.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveAccountToEntitlementRequest
*/
func (a *AccountsAPIService) RemoveAccountToEntitlement(ctx context.Context) ApiRemoveAccountToEntitlementRequest {
	return ApiRemoveAccountToEntitlementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateAccount200Response
func (a *AccountsAPIService) RemoveAccountToEntitlementExecute(r ApiRemoveAccountToEntitlementRequest) (*CreateAccount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAccount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.RemoveAccountToEntitlement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/removeAccountToEntitlement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.securitysystem == nil {
		return localVarReturnValue, nil, reportError("securitysystem is required and must be specified")
	}
	if r.endpoint == nil {
		return localVarReturnValue, nil, reportError("endpoint is required and must be specified")
	}
	if r.accountname == nil {
		return localVarReturnValue, nil, reportError("accountname is required and must be specified")
	}
	if r.entitlementtype == nil {
		return localVarReturnValue, nil, reportError("entitlementtype is required and must be specified")
	}
	if r.entitlementvalue == nil {
		return localVarReturnValue, nil, reportError("entitlementvalue is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "securitysystem", r.securitysystem, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "endpoint", r.endpoint, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "accountname", r.accountname, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "entitlementtype", r.entitlementtype, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "entitlementvalue", r.entitlementvalue, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RemoveAccountToEntitlementDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAccountRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	updateAccountRequest *UpdateAccountRequest
}

// Request payload for updating an account.
func (r ApiUpdateAccountRequest) UpdateAccountRequest(updateAccountRequest UpdateAccountRequest) ApiUpdateAccountRequest {
	r.updateAccountRequest = &updateAccountRequest
	return r
}

func (r ApiUpdateAccountRequest) Execute() (*UpdateAccount200Response, *http.Response, error) {
	return r.ApiService.UpdateAccountExecute(r)
}

/*
UpdateAccount Update Account

This method updates a particular "account" record in Saviynt based on the account name.

The **Authorization** header must have `Bearer` followed by `Token`.

**Mandatory parameters:**
- `securitysystem`: The security system (not the display name).
- `endpoint`: The endpoint (not the display name).
- `name`: The account name.

**Optional parameters:**
- `customproperty1` to `customproperty30`
- `status`
- `description`
- `displayname`
- `comments`
- `accountid`
- `customproperty1` to `customproperty56` (if more than 30 are needed)
- `passwordchangestatus`
- `privileged`
- `usergroup`
- `updateuser`: Username of the user who is updating the account.
- `status`: e.g. "Manually Suspended", "Manually Provisioned", "SUSPENDED FROM IMPORT SERVICE", "1", "2", "3", "4" (default: "1")
- `accounttype`: e.g. "Service Account", "Shared Account", "FIREFIGHTERID" (default: null)
- `incorrectlogons`
- `orphan`: true/false
- `validfrom`: Date in MM-dd-yyyy format
- `validthrough`: Date in MM-dd-yyyy format
- `lastlogondate`: Date in MM-dd-yyyy format
- `passwordlockdate`: Date in MM-dd-yyyy format
- `lastpasswordchange`: Date in MM-dd-yyyy format
- `accountowner`: An array of objects. Each object represents an owner with:
    - **type** (mandatory): "user" or "usergroup"
    - **value** (mandatory): username or usergroup name
    - **rank** (optional): allowed values "1" to "5", "26" (for primary certifier) or "27" (for secondary certifier). Default is "1".
    - **action** (mandatory): "add" or "remove"

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAccountRequest
*/
func (a *AccountsAPIService) UpdateAccount(ctx context.Context) ApiUpdateAccountRequest {
	return ApiUpdateAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateAccount200Response
func (a *AccountsAPIService) UpdateAccountExecute(r ApiUpdateAccountRequest) (*UpdateAccount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateAccount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.UpdateAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/updateAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateAccountRequest == nil {
		return localVarReturnValue, nil, reportError("updateAccountRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAccountRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v UpdateAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
