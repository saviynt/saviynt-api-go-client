/*
Saviynt Job Control API

Saviynt Job Control API Spec

API version: 1.0
Contact: https://github.com/saviynt
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package jobcontrol

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// JobControlAPIService JobControlAPI service
type JobControlAPIService service

type ApiCheckJobStatusRequest struct {
	ctx context.Context
	ApiService *JobControlAPIService
	jobgroup *string
	jobname *string
}

func (r ApiCheckJobStatusRequest) Jobgroup(jobgroup string) ApiCheckJobStatusRequest {
	r.jobgroup = &jobgroup
	return r
}

func (r ApiCheckJobStatusRequest) Jobname(jobname string) ApiCheckJobStatusRequest {
	r.jobname = &jobname
	return r
}

func (r ApiCheckJobStatusRequest) Execute() (*CheckJobStatusResponse, *http.Response, error) {
	return r.ApiService.CheckJobStatusExecute(r)
}

/*
CheckJobStatus Check Job Status

This API is used to fetch the status of any job other than Data Import Job.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCheckJobStatusRequest
*/
func (a *JobControlAPIService) CheckJobStatus(ctx context.Context) ApiCheckJobStatusRequest {
	return ApiCheckJobStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CheckJobStatusResponse
func (a *JobControlAPIService) CheckJobStatusExecute(r ApiCheckJobStatusRequest) (*CheckJobStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckJobStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobControlAPIService.CheckJobStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/checkJobStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jobgroup == nil {
		return localVarReturnValue, nil, reportError("jobgroup is required and must be specified")
	}
	if r.jobname == nil {
		return localVarReturnValue, nil, reportError("jobname is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "jobgroup", r.jobgroup, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "jobname", r.jobname, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTriggersRequest struct {
	ctx context.Context
	ApiService *JobControlAPIService
}

func (r ApiCreateTriggersRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateTriggersExecute(r)
}

/*
CreateTriggers Create Triggers

This API is used to create job triggers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTriggersRequest
*/
func (a *JobControlAPIService) CreateTriggers(ctx context.Context) ApiCreateTriggersRequest {
	return ApiCreateTriggersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *JobControlAPIService) CreateTriggersExecute(r ApiCreateTriggersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobControlAPIService.CreateTriggers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/createTriggers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateUpdateTriggerRequest struct {
	ctx context.Context
	ApiService *JobControlAPIService
}

func (r ApiCreateUpdateTriggerRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateUpdateTriggerExecute(r)
}

/*
CreateUpdateTrigger Create and Update Trigger

This API call can be used to create and update a trigger for a particular `jobgroup` in Saviynt.

Starting with Release v24.7, a new `analysistypes` parameter has been introduced for the **Recommendations** job. To execute an analysis type using this API, you can use the `analysistypes` parameter and specify the following values in its request:

* 0 – Run All Steps
* 1 – Run Attribute Discovery
* 2 – Generate Correlation Rules
* 3 – Rule Consolidation for Access
* 4 – Rule Consolidation for Apps
* 5 – Compute Access Confidence
* 6 – Compute Model Performance Statistics
* 7 – Incremental Rule Creation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateUpdateTriggerRequest
*/
func (a *JobControlAPIService) CreateUpdateTrigger(ctx context.Context) ApiCreateUpdateTriggerRequest {
	return ApiCreateUpdateTriggerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *JobControlAPIService) CreateUpdateTriggerExecute(r ApiCreateUpdateTriggerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobControlAPIService.CreateUpdateTrigger")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/createUpdateTrigger"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTriggerRequest struct {
	ctx context.Context
	ApiService *JobControlAPIService
}

func (r ApiDeleteTriggerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTriggerExecute(r)
}

/*
DeleteTrigger Delete Trigger

This API call can be used to delete a trigger for a particular "jobgroup" in Saviynt.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteTriggerRequest
*/
func (a *JobControlAPIService) DeleteTrigger(ctx context.Context) ApiDeleteTriggerRequest {
	return ApiDeleteTriggerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *JobControlAPIService) DeleteTriggerExecute(r ApiDeleteTriggerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobControlAPIService.DeleteTrigger")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/deleteTrigger"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFetchJobMetadataRequest struct {
	ctx context.Context
	ApiService *JobControlAPIService
	fetchJobMetadataRequest *FetchJobMetadataRequest
}

func (r ApiFetchJobMetadataRequest) FetchJobMetadataRequest(fetchJobMetadataRequest FetchJobMetadataRequest) ApiFetchJobMetadataRequest {
	r.fetchJobMetadataRequest = &fetchJobMetadataRequest
	return r
}

func (r ApiFetchJobMetadataRequest) Execute() (*FetchJobMetadataResponse, *http.Response, error) {
	return r.ApiService.FetchJobMetadataExecute(r)
}

/*
FetchJobMetadata Fetch Job Metadata

This API call return job metadata for the last run of a job in Saviynt.

Note: The structure of the result param in response can change based upon the Job History saved in Saviynt

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFetchJobMetadataRequest
*/
func (a *JobControlAPIService) FetchJobMetadata(ctx context.Context) ApiFetchJobMetadataRequest {
	return ApiFetchJobMetadataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchJobMetadataResponse
func (a *JobControlAPIService) FetchJobMetadataExecute(r ApiFetchJobMetadataRequest) (*FetchJobMetadataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchJobMetadataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobControlAPIService.FetchJobMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/fetchJobMetadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fetchJobMetadataRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumePauseJobsRequest struct {
	ctx context.Context
	ApiService *JobControlAPIService
	resumePauseJobsRequest *ResumePauseJobsRequest
}

func (r ApiResumePauseJobsRequest) ResumePauseJobsRequest(resumePauseJobsRequest ResumePauseJobsRequest) ApiResumePauseJobsRequest {
	r.resumePauseJobsRequest = &resumePauseJobsRequest
	return r
}

func (r ApiResumePauseJobsRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ResumePauseJobsExecute(r)
}

/*
ResumePauseJobs Resume Pause Jobs

Starting with Release v23.10, the `resumePauseJobs` API enables you to pause jobs based on their job type and job name.

When a job is paused, its status is displayed as Paused on the Job Control Panel page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResumePauseJobsRequest
*/
func (a *JobControlAPIService) ResumePauseJobs(ctx context.Context) ApiResumePauseJobsRequest {
	return ApiResumePauseJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *JobControlAPIService) ResumePauseJobsExecute(r ApiResumePauseJobsRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobControlAPIService.ResumePauseJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/resumePauseJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resumePauseJobsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRunJobTriggerRequest struct {
	ctx context.Context
	ApiService *JobControlAPIService
}

func (r ApiRunJobTriggerRequest) Execute() (*http.Response, error) {
	return r.ApiService.RunJobTriggerExecute(r)
}

/*
RunJobTrigger Run Job Trigger

This API call can be used to run a job trigger in Saviynt.

The following cases illustrate different scenarios on the usage of the `analyticsAdvanceQuery` parameter in the API:

* Case 1: When you configure the `analyticsAdvanceQuery` within the payload, set the `defaultActionForAnalytics` as `"true"`, and then execute the control from the API, it overrides the default action and the advanced query configuration within the job trigger.
* Case 2: When you configure the `analyticsAdvanceQuery` within the payload, set the `defaultActionForAnalytics` as `"false"`, and then execute the control from the API without performing the default actions configured in the control, it overrides the default action and the advanced query configuration within the job trigger.
* Case 3: When you do not configure both the `analyticsAdvanceQuery` and the `defaultActionForAnalytics`x, the default action will depend on the configuration provided in the analytics job trigger.

The following cases illustrate different scenarios on the usage of the `analyticsCategories` parameter in the API:

* Case 1: When you set the "defaultActionForAnalytics" as "true" to perform default actions for analytics controls by executing the control from job API, it will override the default action configuration within the job trigger.
* Case 2: When you set the "defaultActionForAnalytics" as "false" to not perform default actions for analytics controls by executing the control from job API, it will override the default action configuration within the job trigger.
* Case 3: When the defaultActionForAnalytics parameter is not set in the payload, the default action will depend on the configuration provided in the analytics job trigger.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRunJobTriggerRequest
*/
func (a *JobControlAPIService) RunJobTrigger(ctx context.Context) ApiRunJobTriggerRequest {
	return ApiRunJobTriggerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *JobControlAPIService) RunJobTriggerExecute(r ApiRunJobTriggerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobControlAPIService.RunJobTrigger")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/runJobTrigger"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
