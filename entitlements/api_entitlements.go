/*
Entitlements Management API

API for creating, updating, retrieving, and deleting Entitlements data in EIC

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// EntitlementsAPIService EntitlementsAPI service
type EntitlementsAPIService service

type ApiCreateUpdateEntitlementRequest struct {
	ctx context.Context
	ApiService *EntitlementsAPIService
	createUpdateEntitlementRequest *CreateUpdateEntitlementRequest
}

func (r ApiCreateUpdateEntitlementRequest) CreateUpdateEntitlementRequest(createUpdateEntitlementRequest CreateUpdateEntitlementRequest) ApiCreateUpdateEntitlementRequest {
	r.createUpdateEntitlementRequest = &createUpdateEntitlementRequest
	return r
}

func (r ApiCreateUpdateEntitlementRequest) Execute() (*CreateUpdateEntitlement200Response, *http.Response, error) {
	return r.ApiService.CreateUpdateEntitlementExecute(r)
}

/*
CreateUpdateEntitlement Create/Update Entitlement

This method creates a new "entitlementvalue" for an "endpoint" in SSM. 
All the input parameters it requires are attributes with which the new account record would get created.

**Ensure:** The `Authorization` header variable must be set to `Bearer` followed by `Token`.

**Mandatory parameters:**
- `endpoint`
- `entitlementtype`
- `entitlement_value`

**Optional parameters:**
- `entitlementattributes` (Additional attributes for Entitlement_values)
- `entitlementowner<N>` - N is the rank, `entitlementowner` modifies entitlementowner with rank 1, `entitlementowner3` modifies entitlementowner with rank 3
- `entitlementID`, `newEntitlementValue` - Used to update entitlement if multiple entitlements with the same `entitlement_value` exist
- `entitlementcasecheck` (Boolean, default: `false`) - If `true`, entitlement value search is case-sensitive during create/update
- `entitlement_valuekey`
- `updatedentitlement_value` - New value for `entitlement_value`
- `entitlementmap` - Contains:
  - `entitlementvalue`
  - `entitlementtype`
  - `endpoint`
  - `requestfilter`
  - `excludeentitlement`
  - `adddependenttask`
  - `removedependententtask`
  - `updateType` (`ADD`/`REMOVE`, default: `ADD`)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateUpdateEntitlementRequest
*/
func (a *EntitlementsAPIService) CreateUpdateEntitlement(ctx context.Context) ApiCreateUpdateEntitlementRequest {
	return ApiCreateUpdateEntitlementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateUpdateEntitlement200Response
func (a *EntitlementsAPIService) CreateUpdateEntitlementExecute(r ApiCreateUpdateEntitlementRequest) (*CreateUpdateEntitlement200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateUpdateEntitlement200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsAPIService.CreateUpdateEntitlement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/createUpdateEntitlement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createUpdateEntitlementRequest == nil {
		return localVarReturnValue, nil, reportError("createUpdateEntitlementRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createUpdateEntitlementRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChildEntitlementsRequest struct {
	ctx context.Context
	ApiService *EntitlementsAPIService
	endpointkey *string
	endpointname *string
	entitlementtypekey *string
	entitlementtypename *string
	parententitlementvalue *string
	parententitlementvaluekey *string
	entquery *string
	childentquery *string
	entitlements2query *string
	responsefields *[]string
	max *int32
	offset *int32
}

func (r ApiGetChildEntitlementsRequest) Endpointkey(endpointkey string) ApiGetChildEntitlementsRequest {
	r.endpointkey = &endpointkey
	return r
}

func (r ApiGetChildEntitlementsRequest) Endpointname(endpointname string) ApiGetChildEntitlementsRequest {
	r.endpointname = &endpointname
	return r
}

func (r ApiGetChildEntitlementsRequest) Entitlementtypekey(entitlementtypekey string) ApiGetChildEntitlementsRequest {
	r.entitlementtypekey = &entitlementtypekey
	return r
}

func (r ApiGetChildEntitlementsRequest) Entitlementtypename(entitlementtypename string) ApiGetChildEntitlementsRequest {
	r.entitlementtypename = &entitlementtypename
	return r
}

func (r ApiGetChildEntitlementsRequest) Parententitlementvalue(parententitlementvalue string) ApiGetChildEntitlementsRequest {
	r.parententitlementvalue = &parententitlementvalue
	return r
}

func (r ApiGetChildEntitlementsRequest) Parententitlementvaluekey(parententitlementvaluekey string) ApiGetChildEntitlementsRequest {
	r.parententitlementvaluekey = &parententitlementvaluekey
	return r
}

func (r ApiGetChildEntitlementsRequest) Entquery(entquery string) ApiGetChildEntitlementsRequest {
	r.entquery = &entquery
	return r
}

func (r ApiGetChildEntitlementsRequest) Childentquery(childentquery string) ApiGetChildEntitlementsRequest {
	r.childentquery = &childentquery
	return r
}

func (r ApiGetChildEntitlementsRequest) Entitlements2query(entitlements2query string) ApiGetChildEntitlementsRequest {
	r.entitlements2query = &entitlements2query
	return r
}

func (r ApiGetChildEntitlementsRequest) Responsefields(responsefields []string) ApiGetChildEntitlementsRequest {
	r.responsefields = &responsefields
	return r
}

func (r ApiGetChildEntitlementsRequest) Max(max int32) ApiGetChildEntitlementsRequest {
	r.max = &max
	return r
}

func (r ApiGetChildEntitlementsRequest) Offset(offset int32) ApiGetChildEntitlementsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetChildEntitlementsRequest) Execute() (*GetChildEntitlements200Response, *http.Response, error) {
	return r.ApiService.GetChildEntitlementsExecute(r)
}

/*
GetChildEntitlements Get Child Entitlements

This API can be used to get the list of all child entitlements.
The `Authorization` must have `Bearer` followed by `Token`.

**Mandatory params:**
- `endpointname` or `endpointkey` (if both are passed, `endpointkey` is considered)

**Optional params:**
- `entitlementtypekey` or `entitlementtypename` (if both are passed, `entitlementtypekey` is considered)
- `parententitlementvalue` or `parententitlementvaluekey` (if both are passed, `parententitlementvaluekey` is considered)
- `entquery` - Query to support parent entitlement values (e.g., `"pev.status = 1"`)
- `childentquery` - Query to support child entitlement values (e.g., `"cev.customproperty3 = '25'"`)
- `entitlements2query` - Query to support entitlements2 parameters (e.g., `"e2.jobId is not null"`)
- `responsefields` - List of child entitlement fields to return (e.g., `["description","customproperty1","customproperty3","displayname"]`)
- `max` - Maximum number of records to return
- `offset` - Pagination offset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChildEntitlementsRequest
*/
func (a *EntitlementsAPIService) GetChildEntitlements(ctx context.Context) ApiGetChildEntitlementsRequest {
	return ApiGetChildEntitlementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetChildEntitlements200Response
func (a *EntitlementsAPIService) GetChildEntitlementsExecute(r ApiGetChildEntitlementsRequest) (*GetChildEntitlements200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChildEntitlements200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsAPIService.GetChildEntitlements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/getChildEntitlements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.endpointkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endpointkey", r.endpointkey, "form", "")
	}
	if r.endpointname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endpointname", r.endpointname, "form", "")
	}
	if r.entitlementtypekey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entitlementtypekey", r.entitlementtypekey, "form", "")
	}
	if r.entitlementtypename != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entitlementtypename", r.entitlementtypename, "form", "")
	}
	if r.parententitlementvalue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parententitlementvalue", r.parententitlementvalue, "form", "")
	}
	if r.parententitlementvaluekey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parententitlementvaluekey", r.parententitlementvaluekey, "form", "")
	}
	if r.entquery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entquery", r.entquery, "form", "")
	}
	if r.childentquery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "childentquery", r.childentquery, "form", "")
	}
	if r.entitlements2query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entitlements2query", r.entitlements2query, "form", "")
	}
	if r.responsefields != nil {
		t := *r.responsefields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "responsefields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "responsefields", t, "form", "multi")
		}
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEntitlementValuesForEndpointRequest struct {
	ctx context.Context
	ApiService *EntitlementsAPIService
	getEntitlementValuesForEndpointRequest *GetEntitlementValuesForEndpointRequest
}

func (r ApiGetEntitlementValuesForEndpointRequest) GetEntitlementValuesForEndpointRequest(getEntitlementValuesForEndpointRequest GetEntitlementValuesForEndpointRequest) ApiGetEntitlementValuesForEndpointRequest {
	r.getEntitlementValuesForEndpointRequest = &getEntitlementValuesForEndpointRequest
	return r
}

func (r ApiGetEntitlementValuesForEndpointRequest) Execute() (*GetEntitlementValuesForEndpoint200Response, *http.Response, error) {
	return r.ApiService.GetEntitlementValuesForEndpointExecute(r)
}

/*
GetEntitlementValuesForEndpoint Get Entitlement Values For Endpoint

This method returns a `List` of "EntitlementValues" for a specific endpoint in SSM. 

The `Authorization` must have `Bearer` followed by `Token`.

Mandatory params:
`endpoint`

Optional params:
`entitlementType`, `max`, `offset`,
`entownerwithrank` - if "true", returns the list of owners with owner rank for every entitlementValue
`returnentitlementmap`(true/false,default:false) - If true, entitlementmap details will be returned

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEntitlementValuesForEndpointRequest
*/
func (a *EntitlementsAPIService) GetEntitlementValuesForEndpoint(ctx context.Context) ApiGetEntitlementValuesForEndpointRequest {
	return ApiGetEntitlementValuesForEndpointRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEntitlementValuesForEndpoint200Response
func (a *EntitlementsAPIService) GetEntitlementValuesForEndpointExecute(r ApiGetEntitlementValuesForEndpointRequest) (*GetEntitlementValuesForEndpoint200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEntitlementValuesForEndpoint200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsAPIService.GetEntitlementValuesForEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/getEntitlementValuesForEndpoint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getEntitlementValuesForEndpointRequest == nil {
		return localVarReturnValue, nil, reportError("getEntitlementValuesForEndpointRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEntitlementValuesForEndpointRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEntitlementsRequest struct {
	ctx context.Context
	ApiService *EntitlementsAPIService
	username *string
	entitlementType *string
	endpoint *string
	requestedObject *string
	max *int32
	offset *int32
	entitlementResponseFields *[]string
	userResponseFields *[]string
	userfiltercriteria *string
	accountname *string
	entownerwithrank *bool
	returnentitlementmap *bool
	exactmatch *bool
	entitlementfiltercriteria *string
	entQuery *string
}

func (r ApiGetEntitlementsRequest) Username(username string) ApiGetEntitlementsRequest {
	r.username = &username
	return r
}

func (r ApiGetEntitlementsRequest) EntitlementType(entitlementType string) ApiGetEntitlementsRequest {
	r.entitlementType = &entitlementType
	return r
}

func (r ApiGetEntitlementsRequest) Endpoint(endpoint string) ApiGetEntitlementsRequest {
	r.endpoint = &endpoint
	return r
}

func (r ApiGetEntitlementsRequest) RequestedObject(requestedObject string) ApiGetEntitlementsRequest {
	r.requestedObject = &requestedObject
	return r
}

func (r ApiGetEntitlementsRequest) Max(max int32) ApiGetEntitlementsRequest {
	r.max = &max
	return r
}

func (r ApiGetEntitlementsRequest) Offset(offset int32) ApiGetEntitlementsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetEntitlementsRequest) EntitlementResponseFields(entitlementResponseFields []string) ApiGetEntitlementsRequest {
	r.entitlementResponseFields = &entitlementResponseFields
	return r
}

func (r ApiGetEntitlementsRequest) UserResponseFields(userResponseFields []string) ApiGetEntitlementsRequest {
	r.userResponseFields = &userResponseFields
	return r
}

func (r ApiGetEntitlementsRequest) Userfiltercriteria(userfiltercriteria string) ApiGetEntitlementsRequest {
	r.userfiltercriteria = &userfiltercriteria
	return r
}

func (r ApiGetEntitlementsRequest) Accountname(accountname string) ApiGetEntitlementsRequest {
	r.accountname = &accountname
	return r
}

func (r ApiGetEntitlementsRequest) Entownerwithrank(entownerwithrank bool) ApiGetEntitlementsRequest {
	r.entownerwithrank = &entownerwithrank
	return r
}

func (r ApiGetEntitlementsRequest) Returnentitlementmap(returnentitlementmap bool) ApiGetEntitlementsRequest {
	r.returnentitlementmap = &returnentitlementmap
	return r
}

func (r ApiGetEntitlementsRequest) Exactmatch(exactmatch bool) ApiGetEntitlementsRequest {
	r.exactmatch = &exactmatch
	return r
}

func (r ApiGetEntitlementsRequest) Entitlementfiltercriteria(entitlementfiltercriteria string) ApiGetEntitlementsRequest {
	r.entitlementfiltercriteria = &entitlementfiltercriteria
	return r
}

func (r ApiGetEntitlementsRequest) EntQuery(entQuery string) ApiGetEntitlementsRequest {
	r.entQuery = &entQuery
	return r
}

func (r ApiGetEntitlementsRequest) Execute() (*GetEntitlements200Response, *http.Response, error) {
	return r.ApiService.GetEntitlementsExecute(r)
}

/*
GetEntitlements Get Entitlements

This API can be used to get the list of all the entitlements.

This API call can be used to get the list and details of all the entitlements the user has access to.

This API will return only the entitlement attributes which are not null or not empty.

The `Authorization` must have `Bearer` followed by `Token`.

**Optional parameters:**  
`username`, `entitlementtype`, `endpoint`, `requestedObject` ("users", "userscount"), `max`, `offset`,  
`entitlementResponseFields`, `userResponseFields`, `userfiltercriteria`, `accountname`,  
`entownerwithrank` (if "true", returns the list of owners with owner rank for every entitlementValue),  
`returnentitlementmap` (true/false, default: false) - If true, entitlementmap details will be returned,  
`exactmatch` - Default is true. If false, it will search based on similar matches.  

Either pass `entitlementfiltercriteria` (with or without `exactmatch`) **OR** `entQuery`.  
**Both cannot be passed simultaneously.**


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEntitlementsRequest
*/
func (a *EntitlementsAPIService) GetEntitlements(ctx context.Context) ApiGetEntitlementsRequest {
	return ApiGetEntitlementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEntitlements200Response
func (a *EntitlementsAPIService) GetEntitlementsExecute(r ApiGetEntitlementsRequest) (*GetEntitlements200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEntitlements200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsAPIService.GetEntitlements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/getEntitlements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "form", "")
	}
	if r.entitlementType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entitlementType", r.entitlementType, "form", "")
	}
	if r.endpoint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endpoint", r.endpoint, "form", "")
	}
	if r.requestedObject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requestedObject", r.requestedObject, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.entitlementResponseFields != nil {
		t := *r.entitlementResponseFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "entitlementResponseFields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "entitlementResponseFields", t, "form", "multi")
		}
	}
	if r.userResponseFields != nil {
		t := *r.userResponseFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userResponseFields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userResponseFields", t, "form", "multi")
		}
	}
	if r.userfiltercriteria != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userfiltercriteria", r.userfiltercriteria, "form", "")
	}
	if r.accountname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountname", r.accountname, "form", "")
	}
	if r.entownerwithrank != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entownerwithrank", r.entownerwithrank, "form", "")
	}
	if r.returnentitlementmap != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnentitlementmap", r.returnentitlementmap, "form", "")
	} else {
		var defaultValue bool = false
		r.returnentitlementmap = &defaultValue
	}
	if r.exactmatch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exactmatch", r.exactmatch, "form", "")
	} else {
		var defaultValue bool = true
		r.exactmatch = &defaultValue
	}
	if r.entitlementfiltercriteria != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entitlementfiltercriteria", r.entitlementfiltercriteria, "form", "")
	}
	if r.entQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entQuery", r.entQuery, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListOfPrivilegesForEntitlementTypeRequest struct {
	ctx context.Context
	ApiService *EntitlementsAPIService
	endpoint *string
	entitlementtype *string
	max *string
	offset *string
}

func (r ApiGetListOfPrivilegesForEntitlementTypeRequest) Endpoint(endpoint string) ApiGetListOfPrivilegesForEntitlementTypeRequest {
	r.endpoint = &endpoint
	return r
}

func (r ApiGetListOfPrivilegesForEntitlementTypeRequest) Entitlementtype(entitlementtype string) ApiGetListOfPrivilegesForEntitlementTypeRequest {
	r.entitlementtype = &entitlementtype
	return r
}

// Maximum number of records to return.
func (r ApiGetListOfPrivilegesForEntitlementTypeRequest) Max(max string) ApiGetListOfPrivilegesForEntitlementTypeRequest {
	r.max = &max
	return r
}

// Pagination offset.
func (r ApiGetListOfPrivilegesForEntitlementTypeRequest) Offset(offset string) ApiGetListOfPrivilegesForEntitlementTypeRequest {
	r.offset = &offset
	return r
}

func (r ApiGetListOfPrivilegesForEntitlementTypeRequest) Execute() (*GetListOfPrivilegesForEntitlementType200Response, *http.Response, error) {
	return r.ApiService.GetListOfPrivilegesForEntitlementTypeExecute(r)
}

/*
GetListOfPrivilegesForEntitlementType Get List of Privileges for Entitlement Type

This API gives the list of privileges for an entitlement type.

The `Authorization` must have `Bearer` followed by `Token`. 

Mandatory params:
`endpoint`

Optional params:
`max`, `offset`, `entitlementType`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetListOfPrivilegesForEntitlementTypeRequest
*/
func (a *EntitlementsAPIService) GetListOfPrivilegesForEntitlementType(ctx context.Context) ApiGetListOfPrivilegesForEntitlementTypeRequest {
	return ApiGetListOfPrivilegesForEntitlementTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetListOfPrivilegesForEntitlementType200Response
func (a *EntitlementsAPIService) GetListOfPrivilegesForEntitlementTypeExecute(r ApiGetListOfPrivilegesForEntitlementTypeRequest) (*GetListOfPrivilegesForEntitlementType200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetListOfPrivilegesForEntitlementType200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsAPIService.GetListOfPrivilegesForEntitlementType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/getListofPrivileges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpoint == nil {
		return localVarReturnValue, nil, reportError("endpoint is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "endpoint", r.endpoint, "", "")
	if r.entitlementtype != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "entitlementtype", r.entitlementtype, "", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "max", r.max, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "offset", r.offset, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveEntitlementFromRoleRequest struct {
	ctx context.Context
	ApiService *EntitlementsAPIService
	removeEntitlementFromRoleRequest *RemoveEntitlementFromRoleRequest
}

func (r ApiRemoveEntitlementFromRoleRequest) RemoveEntitlementFromRoleRequest(removeEntitlementFromRoleRequest RemoveEntitlementFromRoleRequest) ApiRemoveEntitlementFromRoleRequest {
	r.removeEntitlementFromRoleRequest = &removeEntitlementFromRoleRequest
	return r
}

func (r ApiRemoveEntitlementFromRoleRequest) Execute() (*RemoveEntitlementFromRole200Response, *http.Response, error) {
	return r.ApiService.RemoveEntitlementFromRoleExecute(r)
}

/*
RemoveEntitlementFromRole Remove Entitlement From Role

This API removes entitlement from role.
The `Authorization` must have `Bearer` followed by `Token`.
Mandatory params:
`rolename` or `rolekey` (if both are passed then rolekey will be considered), `entitlements`(within list of entitlements entitlementvalue, entitlementtype, endpoint are mandatory)
Optional params:
`requestor`, `comments`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveEntitlementFromRoleRequest
*/
func (a *EntitlementsAPIService) RemoveEntitlementFromRole(ctx context.Context) ApiRemoveEntitlementFromRoleRequest {
	return ApiRemoveEntitlementFromRoleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RemoveEntitlementFromRole200Response
func (a *EntitlementsAPIService) RemoveEntitlementFromRoleExecute(r ApiRemoveEntitlementFromRoleRequest) (*RemoveEntitlementFromRole200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemoveEntitlementFromRole200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsAPIService.RemoveEntitlementFromRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ECM/api/v5/removeEntitlementsFromRole"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.removeEntitlementFromRoleRequest == nil {
		return localVarReturnValue, nil, reportError("removeEntitlementFromRoleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeEntitlementFromRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
